<!DOCTYPE html>
<html>
<head>
    <title>WALL-E</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #050608;
            --bg-panel: #0b0d10;
            --bg-panel-alt: #111318;
            --border-soft: #1f2933;
            --accent: #ffffff;
            --accent-soft: rgba(249, 115, 22, 0.2);
            --text-main: #f9fafb;
            --text-muted: #9ca3af;
            --danger: #ef4444;
            --success: #22c55e;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 24px;
            background: radial-gradient(circle at top, #111827 0, #02040a 45%, #000000 100%);
            color: var(--text-main);
        }

        .container {
            max-width: 1320px;
            margin: 0 auto;
            background: linear-gradient(145deg, rgba(6, 9, 18, 0.9), rgba(3, 7, 18, 0.98));
            padding: 20px 24px 28px 24px;
            border-radius: 18px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            box-shadow:
                0 24px 80px rgba(0, 0, 0, 0.9),
                0 0 0 1px rgba(12, 17, 28, 0.9);
            backdrop-filter: blur(12px);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(55, 65, 81, 0.7);
        }

        .header-left h1 {
            font-size: 24px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            margin: 0 0 4px 0;
            color: var(--text-main);
        }

        .header-left .subline {
            font-size: 12px;
            letter-spacing: 0.24em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .header-right {
            text-align: right;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--text-muted);
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(75, 85, 99, 0.8);
            font-size: 11px;
        }

        .status-indicator {
            width: 7px;
            height: 7px;
            border-radius: 999px;
            background: var(--success);
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.9);
        }

        .dashboard {
            display: grid;
            grid-template-columns: 2.2fr 1.2fr;
            gap: 18px;
        }

        .left-column,
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .panel {
            background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.9), rgba(15, 15, 20, 0.98));
            border-radius: 14px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            padding: 14px 14px 16px 14px;
            position: relative;
            overflow: hidden;
        }

        .panel::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at top left, rgba(249, 115, 22, 0.08), transparent 55%);
            opacity: 0.9;
            pointer-events: none;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .panel-title {
            font-size: 12px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .panel-title span {
            color: var(--accent);
        }

        .panel-tag {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-muted);
            background: rgba(17, 24, 39, 0.9);
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.9);
        }

        .video-layout {
            display: grid;
            grid-template-columns: auto minmax(260px, 1fr);
            gap: 12px;
            align-items: flex-start;
        }



        #videoFeed {
            border-radius: 10px;
            border: 1px solid rgba(75, 85, 99, 0.9);
            background: #000;
            display: block;
        }

        .log-panel {
            display: flex;
            flex-direction: column;
            gap: 6px;
            height: 480px;      
        }



        .logs {
            flex: 1;
            min-height: 0;
            max-height: 100%;     
            overflow-y: auto;
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            background: rgba(3, 7, 18, 0.96);
            padding: 8px 10px;
            font-family: ui-monospace, SFMonoRegular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 11px;
            color: var(--text-main);
        }




        .logs::-webkit-scrollbar {
            width: 6px;
        }

        .logs::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.9);
        }

        .logs::-webkit-scrollbar-thumb {
            background: rgba(75, 85, 99, 0.9);
            border-radius: 999px;
        }

        .log-entry {
            display: grid;
            grid-template-columns: 90px 1fr;
            column-gap: 8px;
            row-gap: 2px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(30, 41, 59, 0.6);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            color: var(--accent);
            text-align: right;
            white-space: nowrap;
        }

        .log-content {
            color: var(--text-muted);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        }

        .stat-card {
            background: rgba(3, 7, 18, 0.96);
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            padding: 8px 10px;
            font-size: 11px;
        }

        .stat-label {
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-main);
        }

        .stat-value.accent {
            color: var(--accent);
        }

        .stat-value.success {
            color: var(--success);
        }

        .stat-value.danger {
            color: var(--danger);
        }

        .controls-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 7px 14px;
            border-radius: 999px;
            border: 1px solid rgba(75, 85, 99, 0.9);
            background: linear-gradient(135deg, #020617, #020617);
            color: var(--text-main);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            cursor: pointer;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(249, 115, 22, 0.25), transparent);
            opacity: 0;
            transition: opacity 120ms ease;
        }

        button:hover::before {
            opacity: 1;
        }

        .btn-start {
            border-color: rgba(34, 197, 94, 0.8);
        }

        .btn-stop {
            border-color: rgba(248, 113, 113, 0.9);
        }

        .btn-clear {
            border-color: rgba(107, 114, 128, 0.9);
        }

        .status {
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            font-size: 11px;
            background: rgba(3, 7, 18, 0.96);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-muted);
        }

        .status-line {
            font-family: ui-monospace, SFMonoRegular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 11px;
            color: var(--text-main);
        }

        .status-detected {
            border-color: rgba(34, 197, 94, 0.8);
            box-shadow: 0 0 24px rgba(34, 197, 94, 0.28);
        }

        .status-idle {
            border-color: rgba(75, 85, 99, 0.9);
        }

        #trajectoryPlot {
            width: 100%;
            height: 220px;
        }

        .trajectory-wrapper {
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            background: rgba(3, 7, 18, 0.96);
            padding: 6px;
        }

        .trajectory-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        .trajectory-meta span {
            color: var(--accent);
        }

        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .video-layout {
                grid-template-columns: 1fr;
            }
            .logs {
                max-height: 200px;
            }
        }

        @media (max-width: 640px) {
            body {
                padding: 12px;
            }
            .container {
                padding: 14px;
            }
            #videoFeed {
                width: 100%;
                height: auto;
            }
        }

                .motion-widget {
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            background: rgba(3, 7, 18, 0.96);
            padding: 8px 8px 10px 8px;
            margin-top: 4px;
        }

        .motion-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        #motionVectorPlot {
            width: 100%;
            height: 200px;
        }

        .motion-readout {
            margin-top: 4px;
            font-size: 10px;
            font-family: ui-monospace, SFMonoRegular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            color: var(--text-muted);
        }

        .motion-readout span {
            color: var(--accent);
        }

                .bottom-row {
            display: flex;
            gap: 16px;
            align-items: stretch;
        }

        .bottom-row .panel {
            flex: 1;
        }

        .regression-widget {
            border-radius: 10px;
            border: 1px solid rgba(31, 41, 55, 0.9);
            background: rgba(3, 7, 18, 0.96);
            padding: 8px 8px 10px 8px;
            margin-top: 8px;
        }

        .regression-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        #regressionPlot {
            width: 100%;
            height: 180px;
        }


    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="header-left">
                <h1>WALL-E</h1>
                <div class="subline">Democratizing trash collection</div>
            </div>
            <div class="header-right">
                <div class="status-pill">
                    <div class="status-indicator" id="globalStatusIndicator"></div>
                    <span id="globalStatusText">Vision Online</span>
                </div>
                <div style="margin-top: 6px;">Team 01</div>
            </div>
        </header>

        <main class="dashboard">
            <section class="left-column">
                <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title"><span>Feed</span> / Detection Channel</div>
                        <div class="panel-tag">Camera Link</div>
                    </div>
                    <div class="video-layout">
                        <img id="videoFeed" src="/video_feed" width="640" height="480" alt="Video feed">
                        <div class="log-panel">
                            <div class="panel-header" style="margin-bottom: 4px;">
                                <div class="panel-title"><span>Log</span> / Events</div>
                                <div class="panel-tag" id="logCountTag">0 logs</div>
                            </div>
                            <div class="logs" id="logContainer">
                                <div id="logs"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title"><span>Trajectory</span> / Position History</div>
                        <div class="panel-tag">Pixels Space</div>
                    </div>
                    <div class="trajectory-wrapper">
                        <div class="trajectory-meta">
                            <div>Plot: X vs Y</div>
                            <div>Anchor: <span>Top Left</span></div>
                        </div>
                        <div id="trajectoryPlot"></div>
                    </div>
                </div> -->
                                <div class="bottom-row">
                    <div class="panel">
                        <div class="panel-header">
                            <div class="panel-title"><span>Control</span> / Session</div>
                            <div class="panel-tag">Command</div>
                        </div>
                        <div class="controls-row">
                            <div class="controls">
                                <button class="btn-start" onclick="toggleTracking(true)">Start</button>
                                <button class="btn-stop" onclick="toggleTracking(false)">Stop</button>
                                <button class="btn-clear" onclick="clearLogs()">Clear Log</button>
                            </div>
                        </div>
                        <div id="status" class="status status-idle">
                            <div class="status-header">
                                <span>Status</span>
                                <span id="statusModeLabel">Idle</span>
                            </div>
                            <div class="status-line" id="statusLine1">Waiting for box detection.</div>
                            <div class="status-line" id="statusLine2">No active target.</div>
                        </div>
                    </div>

                    <div class="panel">
                        <div class="panel-header">
                            <div class="panel-title"><span>System</span> / Telemetry</div>
                            <div class="panel-tag" id="cameraModeTag">Arducam Live</div>
                        </div>
                        <div class="stat-grid">
                            <div class="stat-card">
                                <div class="stat-label">Log Count</div>
                                <div class="stat-value" id="statLogs">0</div>
                            </div>
                            
                            <div class="stat-card">
                                <div class="stat-label">Frame Rate</div>
                                <div class="stat-value" id="statFPS">0.0 fps</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Trajectory Points</div>
                                <div class="stat-value" id="statTrajectory">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Cam Reso</div>
                                <div class="stat-value" id="statResolution">1280x720</div>
                            </div>
                            <!-- <div class="stat-card">
                                <div class="stat-label">Detections</div>
                                <div class="stat-value accent" id="statDetections">0</div>
                            </div> -->
                            <!-- <div class="stat-card">
                                <div class="stat-label">Tracking Status</div>
                                <div class="stat-value success" id="statTracking">Active</div>
                            </div> -->
                            
                        </div>
                    </div>
                </div>
            </section>

            <section class="right-column">
                    <div class="panel">
                    <div class="panel-header">
                        <div class="panel-title"><span>Motion</span> / Trajectory</div>
                        <div class="panel-tag">Vector Field</div>
                    </div>

                    <div class="motion-widget">
                        <div class="motion-meta">
                            <div>Desired accel / velo</div>
                            <div>Goal: frame center</div>
                        </div>
                        <div id="motionVectorPlot"></div>
                        <div class="motion-readout">
                            <div id="motionVelocityText">v_des: vx=0.0, vy=0.0 px/s</div>
                            <div id="motionAccelText">a_des: ax=0.0, ay=0.0 px/s²</div>
                        </div>
                    </div>

                    <div class="regression-widget">
                        <div class="regression-meta">
                            <div>Traj fit</div>
                            <div>LinReg</div>
                        </div>
                        <div id="regressionPlot"></div>
                    </div>
                </div>
                
            </section>
        </main>
    </div>

    <script>
        const socket = io();
        let trajectoryData = { x: [], y: [] };
        let lastUpdate = Date.now();
        let logEntries = 0;
        let trajectoryPoints = [];
        const TRAJECTORY_WINDOW_MS = 500;
        let lastDetectionTime = 0;
        const DETECTION_TIMEOUT_MS = 50;
        let trajMaxX = 1920;  
        let trajMaxY = 1080;
        let desiredMotion = {
            vx: 0,
            vy: 0,
            ax: 0,
            ay: 0,
            hasData: false
        };


        socket.on('detection_update', function(data) {
            updateStatus(data);
            updateTrajectory(data);
            addLog(data);
        });

        socket.on('system_stats', function(data) {
            updateStats(data);
        });

        socket.on('logs_cleared', function() {
            document.getElementById('logs').innerHTML = '';
            trajectoryPoints = [];
            logEntries = 0;
            updateLogCount();
            updatePlot();
        });


        function toggleTracking(enabled) {
            socket.emit('toggle_tracking', { enabled: enabled });
        }

                function clearLogs() {
            const logsDiv = document.getElementById('logs');
            const logContainer = document.getElementById('logContainer');

            if (logsDiv) {
                logsDiv.innerHTML = '';
            }

            logEntries = 0;
            updateLogCount();

            if (logContainer) {
                logContainer.scrollTop = 0;
            }
        }


        function updateStatus(data) {
            const statusDiv = document.getElementById('status');
            const statusModeLabel = document.getElementById('statusModeLabel');
            const statusLine1 = document.getElementById('statusLine1');
            const statusLine2 = document.getElementById('statusLine2');
            const globalIndicator = document.getElementById('globalStatusIndicator');
            const globalText = document.getElementById('globalStatusText');

            const now = Date.now();
            lastDetectionTime = now;  // remember last time we saw a target

            const x = Math.round(data.x);
            const y = Math.round(data.y);
            // const speed = data.speed ? data.speed.toFixed(1) : '0.0';
            // const direction = data.direction ? data.direction.toFixed(1) + ' deg' : 'N/A';

            statusDiv.classList.remove('status-idle');
            statusDiv.classList.add('status-detected');
            statusModeLabel.textContent = 'Target Locked';

            statusLine1.textContent = `[COORD] x=${x}, y=${y}  size=${data.width}x${data.height}`;
            statusLine2.textContent = `Tracking target!`;

            globalIndicator.style.background = '#22c55e';
            globalIndicator.style.boxShadow = '0 0 10px rgba(34, 197, 94, 0.9)';
            globalText.textContent = 'Vision Online';
        }

        function updateIdleStatusIfStale() {
            const now = Date.now();
            if (now - lastDetectionTime > DETECTION_TIMEOUT_MS) {
                const statusDiv = document.getElementById('status');
                const statusModeLabel = document.getElementById('statusModeLabel');
                const statusLine1 = document.getElementById('statusLine1');
                const statusLine2 = document.getElementById('statusLine2');
                const globalIndicator = document.getElementById('globalStatusIndicator');
                const globalText = document.getElementById('globalStatusText');

                statusDiv.classList.remove('status-detected');
                statusDiv.classList.add('status-idle');
                statusModeLabel.textContent = 'Idle';

                statusLine1.textContent = 'Waiting for box detection.';
                statusLine2.textContent = 'No active target.';
            }
        }



        function updateTrajectory(data) {
            const now = Date.now();

            // Add new point with timestamp
            trajectoryPoints.push({
                x: data.x,
                y: data.y,
                t: now
            });

            // Keep only points from the last TRAJECTORY_WINDOW_MS
            trajectoryPoints = trajectoryPoints.filter(p => now - p.t <= TRAJECTORY_WINDOW_MS);

            updatePlot();
        }
        


        function updatePlot() {
            const plotEl = document.getElementById('trajectoryPlot');
            if (!plotEl) return;

            const now = Date.now();

            // drop old points
            trajectoryPoints = trajectoryPoints.filter(
                p => now - p.t <= TRAJECTORY_WINDOW_MS
            );

            const layoutBase = {
                margin: { l: 40, r: 10, t: 4, b: 30 },
                xaxis: {
                    title: { text: 'X (px)', font: { size: 10 } },
                    range: [0, trajMaxX],
                    gridcolor: '#1f2933',
                    zeroline: false
                },
                yaxis: {
                    title: { text: 'Y (px)', font: { size: 10 } },
                    range: [trajMaxY, 0],
                    gridcolor: '#1f2933',
                    zeroline: false,
                    scaleanchor: 'x'
                },
                showlegend: false,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#f9fafb', size: 10 }
            };

            if (trajectoryPoints.length === 0) {
                Plotly.react(
                    'trajectoryPlot',
                    [],
                    layoutBase,
                    { displayModeBar: false, staticPlot: true }  // no zoom or drag
                );
                return;
            }

            const xs = trajectoryPoints.map(p => p.x);
            const ys = trajectoryPoints.map(p => p.y);
            const opacities = trajectoryPoints.map(p => {
                const age = now - p.t;
                const alpha = Math.max(0, Math.min(1, 1 - age / TRAJECTORY_WINDOW_MS));
                return alpha;
            });

            const trace = {
                x: xs,
                y: ys,
                mode: 'lines+markers',
                type: 'scatter',
                line: {
                    width: 5,
                    shape: 'spline'
                },
                marker: {
                    size: 9,
                    opacity: opacities
                }
            };

            Plotly.react(
                'trajectoryPlot',
                [trace],
                layoutBase,
                { displayModeBar: false, staticPlot: true }
            );
        }

        function computeDesiredMotion() {
            // need at least two points and valid resolution
            if (trajectoryPoints.length < 2 || trajMaxX <= 0 || trajMaxY <= 0) {
                desiredMotion = {
                    vx: 0,
                    vy: 0,
                    ax: 0,
                    ay: 0,
                    hasData: false
                };
                return desiredMotion;
            }

            const n = trajectoryPoints.length;
            const pLast = trajectoryPoints[n - 1];
            const pPrev = trajectoryPoints[n - 2];
            const pFirst = trajectoryPoints[0];

            const dt = (pLast.t - pPrev.t) / 1000.0; // seconds
            const cx = trajMaxX / 2;
            const cy = trajMaxY / 2;

            // image-plane error: from frame center to current detection
            const ex = pLast.x - cx;
            const ey = pLast.y - cy;

            // approximate measured velocity in image plane (object)
            let vx_meas = 0;
            let vy_meas = 0;
            if (dt > 0) {
                vx_meas = (pLast.x - pPrev.x) / dt;
                vy_meas = (pLast.y - pPrev.y) / dt;
            }

            // linear regression of trajectory in image plane
            const fit = computeLinearFit(trajectoryPoints);
            if (!fit) {
                desiredMotion = {
                    vx: 0,
                    vy: 0,
                    ax: 0,
                    ay: 0,
                    hasData: false
                };
                return desiredMotion;
            }

            // unit direction along line of best fit
            let dirX;
            let dirY;
            if (fit.slope === null) {
                // vertical line
                dirX = 0;
                dirY = 1;
            } else {
                dirX = 1;
                dirY = fit.slope;
                const mag = Math.hypot(dirX, dirY);
                if (mag > 0) {
                    dirX /= mag;
                    dirY /= mag;
                }
            }

            // choose sign so that direction matches overall motion (first to last)
            const dxFL = pLast.x - pFirst.x;
            const dyFL = pLast.y - pFirst.y;
            const sign = (dxFL * dirX + dyFL * dirY) >= 0 ? 1 : -1;
            dirX *= sign;
            dirY *= sign;

            // signed distance from frame center to last point along the fitted line
            const proj = ex * dirX + ey * dirY;

            // desired velocity - move opposite along the trajectory so object tends toward center
            const k_v = 1.0;
            const vx_des = -k_v * proj * dirX;
            const vy_des = -k_v * proj * dirY;

            // desired acceleration chases the desired velocity
            const k_a = 0.5;
            const ax_des = k_a * (vx_des - vx_meas);
            const ay_des = k_a * (vy_des - vy_meas);

            desiredMotion = {
                vx: vx_des,
                vy: vy_des,
                ax: ax_des,
                ay: ay_des,
                hasData: true
            };

            return desiredMotion;
        }



        function updateMotionWidget() {
            const plotId = 'motionVectorPlot';
            const plotEl = document.getElementById(plotId);
            if (!plotEl) {
                return;
            }

            const layout = {
                margin: { l: 30, r: 10, t: 10, b: 30 },
                xaxis: {
                    title: { text: 'vx / ax (norm)', font: { size: 9 } },
                    range: [-1, 1],
                    gridcolor: '#1f2933',
                    zeroline: true
                },
                yaxis: {
                    title: { text: 'vy / ay (norm)', font: { size: 9 } },
                    range: [-1, 1],
                    gridcolor: '#1f2933',
                    zeroline: true,
                    scaleanchor: 'x'
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    y: -0.2,
                    x: 0.0
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#f9fafb', size: 9 }
            };

            const motion = computeDesiredMotion();

            const velTextEl = document.getElementById('motionVelocityText');
            const accTextEl = document.getElementById('motionAccelText');

            if (!motion.hasData) {
                Plotly.react(plotId, [], layout, { displayModeBar: false, staticPlot: true });
                if (velTextEl) {
                    velTextEl.textContent = 'v_des: vx=0.0, vy=0.0 px/s';
                }
                if (accTextEl) {
                    accTextEl.textContent = 'a_des: ax=0.0, ay=0.0 px/s²';
                }
                return;
            }

            // normalize vectors so they fit nicely in [-1, 1] and flip y for display
            const vMag = Math.hypot(motion.vx, motion.vy);
            const aMag = Math.hypot(motion.ax, motion.ay);
            const maxMag = Math.max(vMag, aMag, 1e-6);
            const scale = 0.8 / maxMag;

            function normForPlot(x, y) {
                return {
                    x: x * scale,
                    y: -y * scale   // invert y so "up" is up in the widget
                };
            }

            const vNorm = normForPlot(motion.vx, motion.vy);
            const aNorm = normForPlot(motion.ax, motion.ay);

            const traces = [
                {
                    x: [0, vNorm.x],
                    y: [0, vNorm.y],
                    mode: 'lines+markers',
                    type: 'scatter',
                    name: 'v_des',
                    line: { width: 3 },
                    marker: { size: 6 }
                },
                {
                    x: [0, aNorm.x],
                    y: [0, aNorm.y],
                    mode: 'lines+markers',
                    type: 'scatter',
                    name: 'a_des',
                    line: { width: 3, dash: 'dot' },
                    marker: { size: 6 }
                }
            ];

            Plotly.react(plotId, traces, layout, { displayModeBar: false, staticPlot: true });

            if (velTextEl) {
                velTextEl.textContent =
                    `v_des: vx=${motion.vx.toFixed(1)}, vy=${motion.vy.toFixed(1)} px/s`;
            }
            if (accTextEl) {
                accTextEl.textContent =
                    `a_des: ax=${motion.ax.toFixed(1)}, ay=${motion.ay.toFixed(1)} px/s²`;
            }
        }

                function updateRegressionPlot() {
            const plotId = 'regressionPlot';
            const plotEl = document.getElementById(plotId);
            if (!plotEl) {
                return;
            }

            const now = Date.now();
            // keep the same time window as trajectory
            trajectoryPoints = trajectoryPoints.filter(
                p => now - p.t <= TRAJECTORY_WINDOW_MS
            );

            const layout = {
                margin: { l: 40, r: 10, t: 10, b: 30 },
                xaxis: {
                    title: { text: 'X (px)', font: { size: 9 } },
                    range: [0, trajMaxX],
                    gridcolor: '#1f2933',
                    zeroline: false
                },
                yaxis: {
                    title: { text: 'Y (px)', font: { size: 9 } },
                    range: [trajMaxY, 0],
                    gridcolor: '#1f2933',
                    zeroline: false,
                    scaleanchor: 'x'
                },
                showlegend: true,
                legend: {
                    orientation: 'h',
                    y: -0.2,
                    x: 0.0
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#f9fafb', size: 9 }
            };

            if (trajectoryPoints.length < 2) {
                Plotly.react(plotId, [], layout, { displayModeBar: false, staticPlot: true });
                return;
            }

            const xs = trajectoryPoints.map(p => p.x);
            const ys = trajectoryPoints.map(p => p.y);

            const scatterTrace = {
                x: xs,
                y: ys,
                mode: 'markers',
                type: 'scatter',
                name: 'trajectory',
                marker: { size: 6 }
            };

            const fit = computeLinearFit(trajectoryPoints);
            let lineTrace = null;

            if (fit) {
                if (fit.slope === null) {
                    // vertical line at meanX
                    const x0 = fit.meanX;
                    const x1 = fit.meanX;
                    lineTrace = {
                        x: [x0, x1],
                        y: [0, trajMaxY],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'line of best fit',
                        line: { width: 2, dash: 'dot' }
                    };
                } else {
                    const x0 = 0;
                    const x1 = trajMaxX;
                    const y0 = fit.slope * x0 + fit.intercept;
                    const y1 = fit.slope * x1 + fit.intercept;
                    lineTrace = {
                        x: [x0, x1],
                        y: [y0, y1],
                        mode: 'lines',
                        type: 'scatter',
                        name: 'line of best fit',
                        line: { width: 2, dash: 'dot' }
                    };
                }
            }

            const traces = lineTrace ? [scatterTrace, lineTrace] : [scatterTrace];

            Plotly.react(plotId, traces, layout, { displayModeBar: false, staticPlot: true });
        }


        function computeLinearFit(points) {
            const n = points.length;
            if (n < 2) {
                return null;
            }

            let sumX = 0;
            let sumY = 0;
            for (const p of points) {
                sumX += p.x;
                sumY += p.y;
            }
            const meanX = sumX / n;
            const meanY = sumY / n;

            let num = 0;
            let den = 0;
            for (const p of points) {
                const dx = p.x - meanX;
                const dy = p.y - meanY;
                num += dx * dy;
                den += dx * dx;
            }

            // null slope means vertical line x = meanX
            const slope = den === 0 ? null : num / den;
            const intercept = slope === null ? null : (meanY - slope * meanX);

            return { slope, intercept, meanX, meanY };
        }




        function updateStats(data) {
            // const detEl = document.getElementById('statDetections');
            const fpsEl = document.getElementById('statFPS');
            const trajEl = document.getElementById('statTrajectory');
            const logsEl = document.getElementById('statLogs');
            // const trackEl = document.getElementById('statTracking');
            const resEl = document.getElementById('statResolution');
            const modeTag = document.getElementById('cameraModeTag');
            const globalIndicator = document.getElementById('globalStatusIndicator');
            const globalText = document.getElementById('globalStatusText');

            // detEl.textContent = data.detection_count;
            fpsEl.textContent = `${data.fps.toFixed(1)} fps`;
            trajEl.textContent = trajectoryPoints.length;

            // use frontend counter for logs
            logsEl.textContent = logEntries;

            // parse resolution string like "1920x1080"
            if (data.resolution) {
                resEl.textContent = data.resolution.replace('x', ' x ');
                const parts = data.resolution.split('x');
                if (parts.length === 2) {
                    const w = parseInt(parts[0].trim(), 10);
                    const h = parseInt(parts[1].trim(), 10);
                    if (!Number.isNaN(w) && !Number.isNaN(h)) {
                        trajMaxX = w;
                        trajMaxY = h;
                    }
                }
            } else {
                resEl.textContent = '1280 x 720';
                trajMaxX = 1280;
                trajMaxY = 720;
            }

            // if (data.tracking_enabled) {
            //     trackEl.textContent = 'Active';
            //     trackEl.classList.remove('danger');
            //     trackEl.classList.add('success');
            //     globalIndicator.style.background = '#22c55e';
            //     globalIndicator.style.boxShadow = '0 0 10px rgba(34, 197, 94, 0.9)';
            //     globalText.textContent = 'Tracking Online';
            // } else {
            //     trackEl.textContent = 'Paused';
            //     trackEl.classList.remove('success');
            //     trackEl.classList.add('danger');
            //     globalIndicator.style.background = '#ef4444';
            //     globalIndicator.style.boxShadow = '0 0 10px rgba(239, 68, 68, 0.9)';
            //     globalText.textContent = 'Tracking Paused';
            // }

            modeTag.textContent = data.test_mode ? 'Test Mode' : 'Arducam Live';
}

        function addLog(data) {
            const logsDiv = document.getElementById('logs');
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();

            const x = Math.round(data.x);
            const y = Math.round(data.y);
            // const speed = data.speed ? data.speed.toFixed(1) : '0.0';

            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const ts = document.createElement('div');
            ts.className = 'log-timestamp';
            ts.textContent = `[${timestamp}]`;

            const content = document.createElement('div');
            content.className = 'log-content';
            content.textContent = `coord: x=${x}, y=${y}  size=${data.width}x${data.height}`;

            entry.appendChild(ts);
            entry.appendChild(content);
            logsDiv.appendChild(entry);

            logEntries += 1;
            updateLogCount();

            // auto scroll to bottom
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function updateLogCount() {
            const tag = document.getElementById('logCountTag');
            tag.textContent = `${logEntries} logs`;
            const statLogs = document.getElementById('statLogs');
            if (statLogs && !Number.isNaN(logEntries)) {
                statLogs.textContent = logEntries;
            }
        }

        updateIdleStatusIfStale();
        updatePlot();
        updateMotionWidget();
        updateRegressionPlot();

        setInterval(updatePlot, 100);
        setInterval(updateMotionWidget, 100);
        setInterval(updateRegressionPlot, 100);
        setInterval(updateIdleStatusIfStale, 100);

    </script>
</body>
</html>
